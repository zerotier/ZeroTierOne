// (c) 2020-2022 ZeroTier, Inc. -- currently proprietary pending actual release and licensing. See LICENSE.md.

// ZSSP: ZeroTier Secure Session Protocol
// FIPS compliant Noise_IK with Jedi powers and built-in attack-resistant large payload (fragmentation) support.

use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Mutex, RwLock};

use zerotier_crypto::aes::{Aes, AesGcm};
use zerotier_crypto::hash::{hmac_sha512, HMACSHA384, SHA384};
use zerotier_crypto::p384::{P384KeyPair, P384PublicKey, P384_PUBLIC_KEY_SIZE};
use zerotier_crypto::random;
use zerotier_crypto::secret::Secret;
use zerotier_crypto::secure_eq;

use zerotier_utils::gatherarray::GatherArray;
use zerotier_utils::memory;
use zerotier_utils::ringbuffermap::RingBufferMap;
use zerotier_utils::unlikely_branch;
use zerotier_utils::varint;

use crate::applicationlayer::ApplicationLayer;
use crate::constants::*;
use crate::error::Error;
use crate::sessionid::SessionId;

/// Result generated by the packet receive function, with possible payloads.
pub enum ReceiveResult<'a, H: ApplicationLayer> {
    /// Packet is valid, no action needs to be taken.
    Ok,

    /// Packet is valid and a data payload was decoded and authenticated.
    ///
    /// The returned reference is to the filled parts of the data buffer supplied to receive.
    OkData(&'a mut [u8]),

    /// Packet is valid and a new session was created.
    ///
    /// The session will have already been gated by the accept_new_session() method in ApplicationLayer.
    OkNewSession(Session<H>),

    /// Packet appears valid but was ignored e.g. as a duplicate.
    Ignored,
}

/// State information to associate with receiving contexts such as sockets or remote paths/endpoints.
///
/// This holds the data structures used to defragment incoming packets that are not associated with an
/// existing session, which would be new attempts to create sessions. Typically one of these is associated
/// with a single listen socket, local bound port, or other inbound endpoint.
pub struct ReceiveContext<H: ApplicationLayer> {
    initial_offer_defrag: Mutex<RingBufferMap<u64, GatherArray<H::IncomingPacketBuffer, KEY_EXCHANGE_MAX_FRAGMENTS>, 1024, 128>>,
    incoming_init_header_check_cipher: Aes,
}

/// A FIPS compliant variant of Noise_IK with hybrid Kyber1024 PQ data forward secrecy.
pub struct Session<Application: ApplicationLayer> {
    /// This side's locally unique session ID
    pub id: SessionId,

    /// An arbitrary application defined object associated with each session
    pub application_data: Application::Data,

    send_counter: AtomicU64,                                      // Outgoing packet counter and nonce state
    receive_window: [AtomicU64; COUNTER_WINDOW_MAX_OUT_OF_ORDER], // Receive window for anti-replay and deduplication
    psk: Secret<64>,                                              // Arbitrary PSK provided by external code
    noise_ss: Secret<48>,                                         // Static raw shared ECDH NIST P-384 key
    header_check_cipher: Aes,                                     // Cipher used for header check codes (not Noise related)
    state: RwLock<SessionMutableState>,                           // Mutable parts of state (other than defrag buffers)
    remote_s_public_blob_hash: [u8; 48],                          // SHA384(remote static public key blob)
    remote_s_public_p384_bytes: [u8; P384_PUBLIC_KEY_SIZE],       // Remote NIST P-384 static public key

    defrag: Mutex<RingBufferMap<u64, GatherArray<Application::IncomingPacketBuffer, MAX_FRAGMENTS>, 8, 8>>,
}

struct SessionMutableState {
    remote_session_id: Option<SessionId>,  // The other side's 48-bit session ID
    session_keys: [Option<SessionKey>; 2], // Buffers to store last and latest key by 1-bit key index
    cur_session_key_idx: usize,            // Pointer to latest session key other side is confirmed to have
    offer: Option<EphemeralOffer>,         // Most recent ephemeral offer sent to remote
    last_remote_offer: i64,                // Time of most recent ephemeral offer (ms)
}

/// A shared symmetric session key.
struct SessionKey {
    ratchet_count: u64,                           // Number of preceding session keys in ratchet
    rekey_at_time: i64,                           // Rekey at or after this time (ticks)
    rekey_at_counter: u64,                        // Rekey at or after this counter
    expire_at_counter: u64,                       // Hard error when this counter value is reached or exceeded
    secret_fingerprint: [u8; 16],                 // First 128 bits of a SHA384 computed from the secret
    ratchet_key: Secret<64>,                      // Ratchet key for deriving the next session key
    receive_key: Secret<AES_KEY_SIZE>,            // Receive side AES-GCM key
    send_key: Secret<AES_KEY_SIZE>,               // Send side AES-GCM key
    receive_cipher_pool: Mutex<Vec<Box<AesGcm>>>, // Pool of reusable sending ciphers
    send_cipher_pool: Mutex<Vec<Box<AesGcm>>>,    // Pool of reusable receiving ciphers
    role: Role,                                   // Was this side Alice or Bob?
    confirmed: bool,                              // We have confirmed that the other side has this key
    jedi: bool,                                   // True if Kyber1024 was used (both sides enabled)
}

/// Alice's KEY_OFFER, remembered so Noise agreement process can resume on KEY_COUNTER_OFFER.
struct EphemeralOffer {
    id: [u8; 16],                                 // Arbitrary random offer ID
    creation_time: i64,                           // Local time when offer was created
    ratchet_count: u64,                           // Ratchet count (starting at zero) for initial offer
    ratchet_key: Option<Secret<64>>,              // Ratchet key from previous offer or None if first offer
    ss_key: Secret<64>,                           // Noise session key "under construction" at state after offer sent
    alice_e_keypair: P384KeyPair,                 // NIST P-384 key pair (Noise ephemeral key for Alice)
    alice_hk_keypair: Option<pqc_kyber::Keypair>, // Kyber1024 key pair (PQ hybrid ephemeral key for Alice)
}

/// Was this side the one who sent the first offer (Alice) or countered (Bob).
///
/// Note that the role can switch through the course of a session. It's the side that most recently
/// initiated a session or a rekey event. Initiator is Alice, responder is Bob.
#[derive(Clone, Copy)]
pub enum Role {
    Alice,
    Bob,
}

impl<Application: ApplicationLayer> Session<Application> {
    /// Create a new session and send an initial key offer message to the other end.
    ///
    /// * `app` - Interface to application using ZSSP
    /// * `local_session_id` - ID for this side (Alice) of the session, must be locally unique
    /// * `remote_s_public_blob` - Remote side's (Bob's) public key/identity
    /// * `offer_metadata` - Arbitrary meta-data to send with key offer (empty if none)
    /// * `psk` - Arbitrary pre-shared key to include as initial key material (use all zeroes if none)
    /// * `application_data` - Arbitrary object to put into session
    /// * `mtu` - Physical wire maximum transmission unit (current value, can change through the course of a session)
    /// * `current_time` - Current monotonic time in milliseconds since an arbitrary time in the past
    pub fn start_new<SendFunction: FnMut(&mut [u8])>(
        app: &Application,
        mut send: SendFunction,
        local_session_id: SessionId,
        remote_s_public_blob: &[u8],
        offer_metadata: &[u8],
        psk: &Secret<64>,
        application_data: Application::Data,
        mtu: usize,
        current_time: i64,
    ) -> Result<Self, Error> {
        let bob_s_public_blob = remote_s_public_blob;
        if let Some(bob_s_public) = Application::extract_s_public_from_raw(bob_s_public_blob) {
            if let Some(noise_ss) = app.get_local_s_keypair().agree(&bob_s_public) {
                let bob_s_public_blob_hash = SHA384::hash(bob_s_public_blob);
                let header_check_cipher =
                    Aes::new(kbkdf512(noise_ss.as_bytes(), KBKDF_KEY_USAGE_LABEL_HEADER_CHECK).first_n::<HEADER_CHECK_AES_KEY_SIZE>());
                let mut offer = None;
                if send_ephemeral_offer(
                    &mut send,
                    1,
                    local_session_id,
                    None,
                    app.get_local_s_public_blob(),
                    offer_metadata,
                    &bob_s_public,
                    &bob_s_public_blob_hash,
                    &noise_ss,
                    None,
                    None,
                    mtu,
                    current_time,
                    &mut offer,
                )
                .is_ok()
                {
                    return Ok(Self {
                        id: local_session_id,
                        application_data,
                        send_counter: AtomicU64::new(2), // 1 was used above
                        receive_window: std::array::from_fn(|_| AtomicU64::new(0)),
                        psk: psk.clone(),
                        noise_ss,
                        header_check_cipher,
                        state: RwLock::new(SessionMutableState {
                            remote_session_id: None,
                            session_keys: [None, None],
                            cur_session_key_idx: 0,
                            offer,
                            last_remote_offer: i64::MIN,
                        }),
                        remote_s_public_blob_hash: bob_s_public_blob_hash,
                        remote_s_public_p384_bytes: bob_s_public.as_bytes().clone(),
                        defrag: Mutex::new(RingBufferMap::new(random::xorshift64_random() as u32)),
                    });
                }
            }
        }
        return Err(Error::InvalidParameter);
    }

    /// Send data over the session.
    ///
    /// * `send` - Function to call to send physical packet(s)
    /// * `mtu_sized_buffer` - A writable work buffer whose size also specifies the physical MTU
    /// * `data` - Data to send
    #[inline]
    pub fn send<SendFunction: FnMut(&mut [u8])>(
        &self,
        mut send: SendFunction,
        mtu_sized_buffer: &mut [u8],
        mut data: &[u8],
    ) -> Result<(), Error> {
        debug_assert!(mtu_sized_buffer.len() >= MIN_TRANSPORT_MTU);
        let state = self.state.read().unwrap();
        if let Some(remote_session_id) = state.remote_session_id {
            if let Some(session_key) = state.session_keys[state.cur_session_key_idx].as_ref() {
                let counter = self.send_counter.fetch_add(1, Ordering::SeqCst);

                let mut c = session_key.get_send_cipher(counter)?;
                c.reset_init_gcm(&create_message_nonce(PACKET_TYPE_DATA, counter));

                let fragment_count =
                    (((data.len() + AES_GCM_TAG_SIZE) as f32) / (mtu_sized_buffer.len() - HEADER_SIZE) as f32).ceil() as usize;
                let fragment_max_chunk_size = mtu_sized_buffer.len() - HEADER_SIZE;
                let last_fragment_no = fragment_count - 1;
                for fragment_no in 0..fragment_count {
                    let chunk_size = fragment_max_chunk_size.min(data.len());
                    let mut fragment_size = chunk_size + HEADER_SIZE;
                    set_packet_header(
                        mtu_sized_buffer,
                        fragment_count,
                        fragment_no,
                        PACKET_TYPE_DATA,
                        u64::from(remote_session_id),
                        session_key.ratchet_count,
                        counter,
                    )?;
                    c.crypt(&data[..chunk_size], &mut mtu_sized_buffer[HEADER_SIZE..fragment_size]);
                    data = &data[chunk_size..];
                    if fragment_no == last_fragment_no {
                        debug_assert!(data.is_empty());
                        let tagged_fragment_size = fragment_size + AES_GCM_TAG_SIZE;
                        mtu_sized_buffer[fragment_size..tagged_fragment_size].copy_from_slice(&c.finish_encrypt());
                        fragment_size = tagged_fragment_size;
                    }
                    self.header_check_cipher
                        .encrypt_block_in_place(&mut mtu_sized_buffer[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
                    send(&mut mtu_sized_buffer[..fragment_size]);
                }
                debug_assert!(data.is_empty());

                session_key.return_send_cipher(c);

                return Ok(());
            } else {
                unlikely_branch();
            }
        } else {
            unlikely_branch();
        }
        return Err(Error::SessionNotEstablished);
    }

    /// Check whether this session is established.
    pub fn established(&self) -> bool {
        let state = self.state.read().unwrap();
        state.remote_session_id.is_some() && state.session_keys[state.cur_session_key_idx].is_some()
    }

    /// Get the shared key fingerprint, ratchet count, and whether Kyber was used, or None if not yet established.
    pub fn status(&self) -> Option<([u8; 16], u64, Role, bool)> {
        let state = self.state.read().unwrap();
        state.session_keys[state.cur_session_key_idx]
            .as_ref()
            .map(|k| (k.secret_fingerprint, k.ratchet_count, k.role, k.jedi))
    }

    /// This function needs to be called on each session at least every SERVICE_INTERVAL milliseconds.
    ///
    /// * `app` - Interface to application using ZSSP
    /// * `send` - Function to call to send physical packet(s)
    /// * `offer_metadata' - Any meta-data to include with initial key offers sent.
    /// * `mtu` - Current physical transport MTU
    /// * `current_time` - Current monotonic time in milliseconds
    /// * `force_expire` - Re-key now regardless of key aging (if it is our turn!)
    pub fn service<SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        mut send: SendFunction,
        offer_metadata: &[u8],
        mtu: usize,
        current_time: i64,
        force_expire: bool,
    ) {
        let state = self.state.read().unwrap();
        if state.session_keys[state.cur_session_key_idx].as_ref().map_or(true, |k| {
            matches!(k.role, Role::Bob)
                && (force_expire || self.send_counter.load(Ordering::Relaxed) >= k.rekey_at_counter || current_time >= k.rekey_at_time)
        }) && state
            .offer
            .as_ref()
            .map_or(true, |o| (current_time - o.creation_time) > Application::REKEY_RATE_LIMIT_MS)
        {
            if let Some(remote_s_public) = P384PublicKey::from_bytes(&self.remote_s_public_p384_bytes) {
                let mut offer = None;
                if send_ephemeral_offer(
                    &mut send,
                    self.send_counter.fetch_add(1, Ordering::SeqCst),
                    self.id,
                    state.remote_session_id,
                    app.get_local_s_public_blob(),
                    offer_metadata,
                    &remote_s_public,
                    &self.remote_s_public_blob_hash,
                    &self.noise_ss,
                    state.session_keys[state.cur_session_key_idx].as_ref(),
                    if state.remote_session_id.is_some() {
                        Some(&self.header_check_cipher)
                    } else {
                        None
                    },
                    mtu,
                    current_time,
                    &mut offer,
                )
                .is_ok()
                {
                    drop(state);
                    let _ = self.state.write().unwrap().offer.replace(offer.unwrap());
                }
            }
        }
    }

    /// Check the receive window without mutating state.
    #[inline(always)]
    fn check_receive_window(&self, counter: u64) -> bool {
        self.receive_window[(counter as usize) % COUNTER_WINDOW_MAX_OUT_OF_ORDER].load(Ordering::Acquire) < counter
    }

    /// Update the receive window, returning true if the packet is still valid.
    /// This should only be called after the packet is authenticated.
    #[inline(always)]
    fn update_receive_window(&self, counter: u64) -> bool {
        self.receive_window[(counter as usize) % COUNTER_WINDOW_MAX_OUT_OF_ORDER].fetch_max(counter, Ordering::AcqRel) < counter
    }
}

impl<Application: ApplicationLayer> ReceiveContext<Application> {
    pub fn new(app: &Application) -> Self {
        Self {
            initial_offer_defrag: Mutex::new(RingBufferMap::new(random::next_u32_secure())),
            incoming_init_header_check_cipher: Aes::new(
                kbkdf512(app.get_local_s_public_blob_hash(), KBKDF_KEY_USAGE_LABEL_HEADER_CHECK).first_n::<HEADER_CHECK_AES_KEY_SIZE>(),
            ),
        }
    }

    /// Receive, authenticate, decrypt, and process a physical wire packet.
    ///
    /// * `app` - Interface to application using ZSSP
    /// * `remote_address` - Remote physical address of source endpoint
    /// * `data_buf` - Buffer to receive decrypted and authenticated object data (an error is returned if too small)
    /// * `incoming_packet_buf` - Buffer containing incoming wire packet (receive() takes ownership)
    /// * `mtu` - Physical wire MTU for sending packets
    /// * `current_time` - Current monotonic time in milliseconds
    #[inline]
    pub fn receive<'a, SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        remote_address: &Application::RemoteAddress,
        mut send: SendFunction,
        data_buf: &'a mut [u8],
        mut incoming_packet_buf: Application::IncomingPacketBuffer,
        mtu: usize,
        current_time: i64,
    ) -> Result<ReceiveResult<'a, Application>, Error> {
        let incoming_packet: &mut [u8] = incoming_packet_buf.as_mut();
        if incoming_packet.len() < MIN_PACKET_SIZE {
            unlikely_branch();
            return Err(Error::InvalidPacket);
        }

        let raw_local_session_id_key_index = memory::load_raw(incoming_packet);
        let key_index = (u64::from_le(raw_local_session_id_key_index).wrapping_shr(47) & 1) as usize;

        if let Some(local_session_id) = SessionId::new_from_u64_le(raw_local_session_id_key_index) {
            if let Some(session) = app.lookup_session(local_session_id) {
                session
                    .header_check_cipher
                    .decrypt_block_in_place(&mut incoming_packet[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
                let raw_header_a = u16::from_le(memory::load_raw(&incoming_packet[6..]));
                let packet_type = (raw_header_a & 0xf) as u8;
                let fragment_count = ((raw_header_a.wrapping_shr(4) & 63) + 1) as u8;
                let fragment_no = raw_header_a.wrapping_shr(10) as u8;
                let counter = u64::from_le(memory::load_raw(&incoming_packet[8..]));

                if session.check_receive_window(counter) {
                    if fragment_count > 1 {
                        if fragment_count <= (MAX_FRAGMENTS as u8) && fragment_no < fragment_count {
                            let mut defrag = session.defrag.lock().unwrap();
                            let fragment_gather_array = defrag.get_or_create_mut(&counter, || GatherArray::new(fragment_count));
                            if let Some(assembled_packet) = fragment_gather_array.add(fragment_no, incoming_packet_buf) {
                                drop(defrag); // release lock
                                return self.receive_complete(
                                    app,
                                    remote_address,
                                    &mut send,
                                    data_buf,
                                    counter,
                                    assembled_packet.as_ref(),
                                    packet_type,
                                    Some(session),
                                    key_index,
                                    mtu,
                                    current_time,
                                );
                            }
                        } else {
                            unlikely_branch();
                            return Err(Error::InvalidPacket);
                        }
                    } else {
                        return self.receive_complete(
                            app,
                            remote_address,
                            &mut send,
                            data_buf,
                            counter,
                            &[incoming_packet_buf],
                            packet_type,
                            Some(session),
                            key_index,
                            mtu,
                            current_time,
                        );
                    }
                } else {
                    unlikely_branch();
                    return Ok(ReceiveResult::Ignored);
                }
            } else {
                unlikely_branch();
                return Err(Error::UnknownLocalSessionId(local_session_id));
            }
        } else {
            unlikely_branch(); // we want data receive to be the priority branch, this is only occasionally used

            self.incoming_init_header_check_cipher
                .decrypt_block_in_place(&mut incoming_packet[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
            let raw_header_a = u16::from_le(memory::load_raw(&incoming_packet[6..]));
            let packet_type = (raw_header_a & 0xf) as u8;
            let fragment_count = ((raw_header_a.wrapping_shr(4) & 63) + 1) as u8;
            let fragment_no = raw_header_a.wrapping_shr(10) as u8;
            let counter = u64::from_le(memory::load_raw(&incoming_packet[8..]));

            if fragment_count > 1 {
                let mut defrag = self.initial_offer_defrag.lock().unwrap();
                let fragment_gather_array = defrag.get_or_create_mut(&counter, || GatherArray::new(fragment_count));
                if let Some(assembled_packet) = fragment_gather_array.add(fragment_no, incoming_packet_buf) {
                    drop(defrag); // release lock
                    return self.receive_complete(
                        app,
                        remote_address,
                        &mut send,
                        data_buf,
                        counter,
                        assembled_packet.as_ref(),
                        packet_type,
                        None,
                        key_index,
                        mtu,
                        current_time,
                    );
                }
            } else {
                return self.receive_complete(
                    app,
                    remote_address,
                    &mut send,
                    data_buf,
                    counter,
                    &[incoming_packet_buf],
                    packet_type,
                    None,
                    key_index,
                    mtu,
                    current_time,
                );
            }
        };

        return Ok(ReceiveResult::Ok);
    }

    /// Called internally when all fragments of a packet are received.
    ///
    /// NOTE: header check codes will already have been validated on receipt of each fragment. AEAD authentication
    /// and decryption has NOT yet been performed, and is done here.
    fn receive_complete<'a, SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        remote_address: &Application::RemoteAddress,
        send: &mut SendFunction,
        data_buf: &'a mut [u8],
        counter: u64,
        fragments: &[Application::IncomingPacketBuffer],
        packet_type: u8,
        session: Option<Application::SessionRef<'a>>,
        key_index: usize,
        mtu: usize,
        current_time: i64,
    ) -> Result<ReceiveResult<'a, Application>, Error> {
        debug_assert!(fragments.len() >= 1);

        // The first 'if' below should capture both DATA and NOP but not other types. Sanity check this.
        debug_assert_eq!(PACKET_TYPE_DATA, 0);
        debug_assert_eq!(PACKET_TYPE_NOP, 1);

        let message_nonce = create_message_nonce(packet_type, counter);

        if packet_type <= PACKET_TYPE_NOP {
            if let Some(session) = session {
                let state = session.state.read().unwrap();
                if let Some(session_key) = state.session_keys[key_index].as_ref() {
                    let mut c = session_key.get_receive_cipher();
                    c.reset_init_gcm(&message_nonce);

                    let mut data_len = 0;

                    // Decrypt fragments 0..N-1 where N is the number of fragments.
                    for f in fragments[..(fragments.len() - 1)].iter() {
                        let f = f.as_ref();
                        debug_assert!(f.len() >= HEADER_SIZE);
                        let current_frag_data_start = data_len;
                        data_len += f.len() - HEADER_SIZE;
                        if data_len > data_buf.len() {
                            unlikely_branch();
                            session_key.return_receive_cipher(c);
                            return Err(Error::DataBufferTooSmall);
                        }
                        c.crypt(&f[HEADER_SIZE..], &mut data_buf[current_frag_data_start..data_len]);
                    }

                    // Decrypt final fragment (or only fragment if not fragmented)
                    let current_frag_data_start = data_len;
                    let last_fragment = fragments.last().unwrap().as_ref();
                    if last_fragment.len() < (HEADER_SIZE + AES_GCM_TAG_SIZE) {
                        unlikely_branch();
                        return Err(Error::InvalidPacket);
                    }
                    data_len += last_fragment.len() - (HEADER_SIZE + AES_GCM_TAG_SIZE);
                    if data_len > data_buf.len() {
                        unlikely_branch();
                        session_key.return_receive_cipher(c);
                        return Err(Error::DataBufferTooSmall);
                    }
                    let payload_end = last_fragment.len() - AES_GCM_TAG_SIZE;
                    c.crypt(
                        &last_fragment[HEADER_SIZE..payload_end],
                        &mut data_buf[current_frag_data_start..data_len],
                    );

                    let gcm_tag = &last_fragment[payload_end..];
                    let aead_authentication_ok = c.finish_decrypt(gcm_tag);
                    session_key.return_receive_cipher(c);

                    if aead_authentication_ok {
                        if session.update_receive_window(counter) {
                            // If the packet authenticated, this confirms that the other side indeed
                            // knows this session key. In that case mark the session key as confirmed
                            // and if the current active key is older switch it to point to this one.
                            if !session_key.confirmed {
                                unlikely_branch();
                                let this_ratchet_count = session_key.ratchet_count;
                                drop(state);
                                let mut state = session.state.write().unwrap();

                                state.session_keys[key_index].as_mut().unwrap().confirmed = true;
                                if state.cur_session_key_idx != key_index {
                                    if let Some(other_session_key) = state.session_keys[state.cur_session_key_idx].as_ref() {
                                        if other_session_key.ratchet_count < this_ratchet_count {
                                            state.cur_session_key_idx = key_index;
                                        }
                                    } else {
                                        state.cur_session_key_idx = key_index;
                                    }
                                }
                            }

                            if packet_type == PACKET_TYPE_DATA {
                                return Ok(ReceiveResult::OkData(&mut data_buf[..data_len]));
                            } else {
                                unlikely_branch();
                                return Ok(ReceiveResult::Ok);
                            }
                        } else {
                            unlikely_branch();
                            return Ok(ReceiveResult::Ignored);
                        }
                    }
                }
                return Err(Error::FailedAuthentication);
            } else {
                unlikely_branch();
                return Err(Error::SessionNotEstablished);
            }
        } else {
            unlikely_branch();

            // To greatly simplify logic handling key exchange packets, assemble these first.
            // Handling KEX packets isn't the fast path so the extra copying isn't significant.
            const KEX_BUF_LEN: usize = 4096;
            let mut kex_packet = [0_u8; KEX_BUF_LEN];
            let mut kex_packet_len = 0;
            for i in 0..fragments.len() {
                let mut ff = fragments[i].as_ref();
                if ff.len() < MIN_PACKET_SIZE {
                    return Err(Error::InvalidPacket);
                }
                if i > 0 {
                    ff = &ff[HEADER_SIZE..];
                }
                let j = kex_packet_len + ff.len();
                if j > KEX_BUF_LEN {
                    return Err(Error::InvalidPacket);
                }
                kex_packet[kex_packet_len..j].copy_from_slice(ff);
                kex_packet_len = j;
            }
            let kex_packet_saved_ciphertext = kex_packet.clone(); // save for HMAC check later

            // Key exchange packets begin (after header) with the session protocol version. This could be
            // changed in the future to support a different cipher suite.
            if kex_packet[HEADER_SIZE] != SESSION_PROTOCOL_VERSION {
                return Err(Error::UnknownProtocolVersion);
            }

            match packet_type {
                PACKET_TYPE_INITIAL_KEY_OFFER => {
                    // alice (remote) -> bob (local)

                    ////////////////////////////////////////////////////////////////
                    // packet decoding for noise initial key offer
                    // -> e, es, s, ss
                    ////////////////////////////////////////////////////////////////

                    if kex_packet_len < (HEADER_SIZE + 1 + P384_PUBLIC_KEY_SIZE + AES_GCM_TAG_SIZE + HMAC_SIZE + HMAC_SIZE) {
                        return Err(Error::InvalidPacket);
                    }

                    let plaintext_end = HEADER_SIZE + 1 + P384_PUBLIC_KEY_SIZE;
                    let payload_end = kex_packet_len - (AES_GCM_TAG_SIZE + HMAC_SIZE + HMAC_SIZE);
                    let aes_gcm_tag_end = kex_packet_len - (HMAC_SIZE + HMAC_SIZE);
                    let hmac1_end = kex_packet_len - HMAC_SIZE;

                    // Check the secondary HMAC first, which proves that the sender knows the recipient's full static identity.
                    if !secure_eq(
                        &hmac_sha384_2(
                            app.get_local_s_public_blob_hash(),
                            &message_nonce,
                            &kex_packet[HEADER_SIZE..hmac1_end],
                        ),
                        &kex_packet[hmac1_end..kex_packet_len],
                    ) {
                        return Err(Error::FailedAuthentication);
                    }

                    // Check rate limits.
                    if let Some(session) = session.as_ref() {
                        if (session.state.read().unwrap().last_remote_offer + Application::REKEY_RATE_LIMIT_MS) > current_time {
                            return Err(Error::RateLimited);
                        }
                    } else {
                        if !app.check_new_session(self, remote_address) {
                            return Err(Error::RateLimited);
                        }
                    }

                    // Key agreement: alice (remote) ephemeral NIST P-384 <> local static NIST P-384
                    let alice_e_public =
                        P384PublicKey::from_bytes(&kex_packet[(HEADER_SIZE + 1)..plaintext_end]).ok_or(Error::FailedAuthentication)?;
                    let noise_es = app
                        .get_local_s_keypair()
                        .agree(&alice_e_public)
                        .ok_or(Error::FailedAuthentication)?;

                    // Initial key derivation from starting point, mixing in alice's ephemeral public and the es.
                    let noise_ik_incomplete_es = Secret(hmac_sha512(
                        &hmac_sha512(&INITIAL_KEY, alice_e_public.as_bytes()),
                        noise_es.as_bytes(),
                    ));

                    // Decrypt the encrypted part of the packet payload and authenticate the above key exchange via AES-GCM auth.
                    let mut c = AesGcm::new(
                        kbkdf512(noise_ik_incomplete_es.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_ALICE_TO_BOB).first_n::<AES_KEY_SIZE>(),
                        false,
                    );
                    c.reset_init_gcm(&message_nonce);
                    c.crypt_in_place(&mut kex_packet[plaintext_end..payload_end]);
                    let gcm_tag = &kex_packet[payload_end..aes_gcm_tag_end];
                    if !c.finish_decrypt(gcm_tag) {
                        return Err(Error::FailedAuthentication);
                    }

                    // Parse payload and get alice's session ID, alice's public blob, metadata, and (if present) Alice's Kyber1024 public.
                    let (
                        offer_id,
                        alice_session_id,
                        alice_s_public_blob,
                        alice_metadata,
                        alice_hk_public_raw,
                        alice_ratchet_key_fingerprint,
                    ) = parse_dec_key_offer_after_header(&kex_packet[plaintext_end..kex_packet_len], packet_type)?;

                    // We either have a session, in which case they should have supplied a ratchet key fingerprint, or
                    // we don't and they should not have supplied one.
                    if session.is_some() != alice_ratchet_key_fingerprint.is_some() {
                        return Err(Error::FailedAuthentication);
                    }

                    // Extract alice's static NIST P-384 public key from her public blob.
                    let alice_s_public = Application::extract_s_public_from_raw(alice_s_public_blob).ok_or(Error::InvalidPacket)?;

                    // Key agreement: both sides' static P-384 keys.
                    let noise_ss = app
                        .get_local_s_keypair()
                        .agree(&alice_s_public)
                        .ok_or(Error::FailedAuthentication)?;

                    // Mix result of 'ss' agreement into master key.
                    let noise_ik_incomplete_es_ss = Secret(hmac_sha512(noise_ik_incomplete_es.as_bytes(), noise_ss.as_bytes()));
                    drop(noise_ik_incomplete_es);

                    // Authenticate entire packet with HMAC-SHA384, verifying alice's identity via 'ss' secret that was
                    // just mixed into the key.
                    if !secure_eq(
                        &hmac_sha384_2(
                            kbkdf512(noise_ik_incomplete_es_ss.as_bytes(), KBKDF_KEY_USAGE_LABEL_HMAC).first_n::<48>(),
                            &message_nonce,
                            &kex_packet_saved_ciphertext[HEADER_SIZE..aes_gcm_tag_end],
                        ),
                        &kex_packet[aes_gcm_tag_end..hmac1_end],
                    ) {
                        return Err(Error::FailedAuthentication);
                    }

                    // Alice's offer has been verified and her current key state reconstructed.

                    // Perform checks and match ratchet key if there's an existing session, or gate (via host) and
                    // then create new sessions.
                    let (new_session, ratchet_key, last_ratchet_count) = if let Some(session) = session.as_ref() {
                        // Existing session identity must match the one in this offer.
                        if !secure_eq(&session.remote_s_public_blob_hash, &SHA384::hash(&alice_s_public_blob)) {
                            return Err(Error::FailedAuthentication);
                        }

                        // Match ratchet key fingerprint and fail if no match, which likely indicates an old offer packet.
                        let alice_ratchet_key_fingerprint = alice_ratchet_key_fingerprint.unwrap();
                        let mut ratchet_key = None;
                        let mut last_ratchet_count = 0;
                        let state = session.state.read().unwrap();
                        for k in state.session_keys.iter() {
                            if let Some(k) = k.as_ref() {
                                if public_fingerprint_of_secret(k.ratchet_key.as_bytes())[..16].eq(alice_ratchet_key_fingerprint) {
                                    ratchet_key = Some(k.ratchet_key.clone());
                                    last_ratchet_count = k.ratchet_count;
                                    break;
                                }
                            }
                        }
                        if ratchet_key.is_none() {
                            return Ok(ReceiveResult::Ignored); // old packet?
                        }

                        (None, ratchet_key, last_ratchet_count)
                    } else {
                        if let Some((new_session_id, psk, associated_object)) =
                            app.accept_new_session(self, remote_address, alice_s_public_blob, alice_metadata)
                        {
                            let header_check_cipher = Aes::new(
                                kbkdf512(noise_ss.as_bytes(), KBKDF_KEY_USAGE_LABEL_HEADER_CHECK).first_n::<HEADER_CHECK_AES_KEY_SIZE>(),
                            );
                            (
                                Some(Session::<Application> {
                                    id: new_session_id,
                                    application_data: associated_object,
                                    receive_window: std::array::from_fn(|_| AtomicU64::new(0)),
                                    send_counter: AtomicU64::new(1),
                                    psk,
                                    noise_ss,
                                    header_check_cipher,
                                    state: RwLock::new(SessionMutableState {
                                        remote_session_id: Some(alice_session_id),
                                        session_keys: [None, None],
                                        cur_session_key_idx: 0,
                                        offer: None,
                                        last_remote_offer: current_time,
                                    }),
                                    remote_s_public_blob_hash: SHA384::hash(&alice_s_public_blob),
                                    remote_s_public_p384_bytes: alice_s_public.as_bytes().clone(),
                                    defrag: Mutex::new(RingBufferMap::new(random::xorshift64_random() as u32)),
                                }),
                                None,
                                0,
                            )
                        } else {
                            return Err(Error::NewSessionRejected);
                        }
                    };

                    // Set 'session' to a reference to either the existing or the new session.
                    let existing_session = session;
                    let session = existing_session.as_ref().map_or_else(|| new_session.as_ref().unwrap(), |s| &*s);

                    if !session.update_receive_window(counter) {
                        return Ok(ReceiveResult::Ignored);
                    }

                    // Generate our ephemeral NIST P-384 key pair.
                    let bob_e_keypair = P384KeyPair::generate();

                    // Key agreement: both sides' ephemeral P-384 public keys.
                    let noise_ee = bob_e_keypair.agree(&alice_e_public).ok_or(Error::FailedAuthentication)?;

                    // Key agreement: bob (local) static NIST P-384, alice (remote) ephemeral P-384.
                    let noise_se = bob_e_keypair.agree(&alice_s_public).ok_or(Error::FailedAuthentication)?;

                    // Mix in the psk, the key to this point, our ephemeral public, ee, and se, completing Noise_IK.
                    //
                    // FIPS note: the order of HMAC parameters are flipped here from the usual Noise HMAC(key, X). That's because
                    // NIST/FIPS allows HKDF with HMAC(salt, key) and salt is allowed to be anything. This way if the PSK is not
                    // FIPS compliant the compliance of the entire key derivation is not invalidated. Both inputs are secrets of
                    // fixed size so this shouldn't matter cryptographically.
                    let noise_ik_complete = Secret(hmac_sha512(
                        session.psk.as_bytes(),
                        &hmac_sha512(
                            &hmac_sha512(
                                &hmac_sha512(noise_ik_incomplete_es_ss.as_bytes(), bob_e_keypair.public_key_bytes()),
                                noise_ee.as_bytes(),
                            ),
                            noise_se.as_bytes(),
                        ),
                    ));
                    drop(noise_ik_incomplete_es_ss);
                    drop(noise_ee);
                    drop(noise_se);

                    // At this point we've completed Noise_IK key derivation with NIST P-384 ECDH, but now for hybrid and ratcheting...

                    // Generate a Kyber encapsulated ciphertext if Kyber is enabled and the other side sent us a public key.
                    let (bob_hk_public, hybrid_kk) = if JEDI && alice_hk_public_raw.len() > 0 {
                        if let Ok((bob_hk_public, hybrid_kk)) =
                            pqc_kyber::encapsulate(alice_hk_public_raw, &mut random::SecureRandom::default())
                        {
                            (Some(bob_hk_public), Some(Secret(hybrid_kk)))
                        } else {
                            return Err(Error::FailedAuthentication);
                        }
                    } else {
                        (None, None)
                    };

                    ////////////////////////////////////////////////////////////////
                    // packet encoding for noise key counter offer
                    // <- e, ee, se
                    ////////////////////////////////////////////////////////////////

                    let next_ratchet_count = last_ratchet_count + 1;

                    let mut reply_buf = [0_u8; KEX_BUF_LEN];
                    let reply_counter = session.send_counter.fetch_add(1, Ordering::SeqCst);
                    let mut idx = HEADER_SIZE;

                    idx = safe_write_all(&mut reply_buf, idx, &[SESSION_PROTOCOL_VERSION])?;
                    idx = safe_write_all(&mut reply_buf, idx, bob_e_keypair.public_key_bytes())?;
                    let plaintext_end = idx;

                    idx = safe_write_all(&mut reply_buf, idx, offer_id)?;
                    idx = safe_write_all(&mut reply_buf, idx, session.id.as_bytes())?;
                    idx = varint_safe_write(&mut reply_buf, idx, 0)?; // they don't need our static public; they have it
                    idx = varint_safe_write(&mut reply_buf, idx, 0)?; // no meta-data in counter-offers (could be used in the future)
                    if let Some(bob_hk_public) = bob_hk_public.as_ref() {
                        idx = safe_write_all(&mut reply_buf, idx, &[HYBRID_KEY_TYPE_KYBER1024])?;
                        idx = safe_write_all(&mut reply_buf, idx, bob_hk_public)?;
                    } else {
                        idx = safe_write_all(&mut reply_buf, idx, &[HYBRID_KEY_TYPE_NONE])?;
                    }
                    if ratchet_key.is_some() {
                        idx = safe_write_all(&mut reply_buf, idx, &[0x01])?;
                        idx = safe_write_all(&mut reply_buf, idx, alice_ratchet_key_fingerprint.unwrap())?;
                    } else {
                        idx = safe_write_all(&mut reply_buf, idx, &[0x00])?;
                    }
                    let payload_end = idx;

                    let reply_message_nonce = create_message_nonce(PACKET_TYPE_KEY_COUNTER_OFFER, reply_counter);

                    // Encrypt reply packet using final Noise_IK key BEFORE mixing hybrid or ratcheting, since the other side
                    // must decrypt before doing these things.
                    let mut c = AesGcm::new(
                        kbkdf512(noise_ik_complete.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_BOB_TO_ALICE).first_n::<AES_KEY_SIZE>(),
                        true,
                    );
                    c.reset_init_gcm(&reply_message_nonce);
                    c.crypt_in_place(&mut reply_buf[plaintext_end..payload_end]);
                    let gcm_tag = c.finish_encrypt();

                    idx = safe_write_all(&mut reply_buf, idx, &gcm_tag)?;
                    let aes_gcm_tag_end = idx;

                    // Mix ratchet key from previous session key (if any) and Kyber1024 hybrid shared key (if any).
                    let mut session_key = noise_ik_complete;
                    if let Some(ratchet_key) = ratchet_key {
                        session_key = Secret(hmac_sha512(ratchet_key.as_bytes(), session_key.as_bytes()));
                    }
                    if let Some(hybrid_kk) = hybrid_kk.as_ref() {
                        session_key = Secret(hmac_sha512(hybrid_kk.as_bytes(), session_key.as_bytes()));
                    }

                    // Authenticate packet using HMAC-SHA384 with final key. Note that while the final key now has the Kyber secret
                    // mixed in, this doesn't constitute session authentication with Kyber because there's no static Kyber key
                    // associated with the remote identity. An attacker who can break NIST P-384 (and has the psk) could MITM the
                    // Kyber exchange, but you'd need a not-yet-existing quantum computer for that.
                    let hmac = hmac_sha384_2(
                        kbkdf512(session_key.as_bytes(), KBKDF_KEY_USAGE_LABEL_HMAC).first_n::<48>(),
                        &reply_message_nonce,
                        &reply_buf[HEADER_SIZE..aes_gcm_tag_end],
                    );
                    idx = safe_write_all(&mut reply_buf, idx, &hmac)?;
                    let packet_end = idx;

                    let session_key = SessionKey::new(
                        session_key,
                        Role::Bob,
                        current_time,
                        reply_counter,
                        next_ratchet_count,
                        false, // Bob can't know yet if Alice got the counter offer
                        hybrid_kk.is_some(),
                    );

                    let next_key_index = (next_ratchet_count as usize) & 1;

                    let mut state = session.state.write().unwrap();
                    let _ = state.remote_session_id.replace(alice_session_id);
                    let _ = state.session_keys[next_key_index].replace(session_key);
                    state.last_remote_offer = current_time;
                    drop(state);

                    // Bob now has final key state for this exchange. Yay! Now reply to Alice so she can construct it.

                    send_with_fragmentation(
                        send,
                        &mut reply_buf[..packet_end],
                        mtu,
                        PACKET_TYPE_KEY_COUNTER_OFFER,
                        u64::from(alice_session_id),
                        next_ratchet_count,
                        reply_counter,
                        &session.header_check_cipher,
                    )?;

                    if new_session.is_some() {
                        return Ok(ReceiveResult::OkNewSession(new_session.unwrap()));
                    } else {
                        return Ok(ReceiveResult::Ok);
                    }
                }

                PACKET_TYPE_KEY_COUNTER_OFFER => {
                    // bob (remote) -> alice (local)

                    ////////////////////////////////////////////////////////////////
                    // packet decoding for noise key counter offer
                    // <- e, ee, se
                    ////////////////////////////////////////////////////////////////

                    if kex_packet_len < (HEADER_SIZE + 1 + P384_PUBLIC_KEY_SIZE + AES_GCM_TAG_SIZE + HMAC_SIZE) {
                        return Err(Error::InvalidPacket);
                    }
                    let plaintext_end = HEADER_SIZE + 1 + P384_PUBLIC_KEY_SIZE;
                    let payload_end = kex_packet_len - (AES_GCM_TAG_SIZE + HMAC_SIZE);
                    let aes_gcm_tag_end = kex_packet_len - HMAC_SIZE;

                    if let Some(session) = session {
                        let state = session.state.read().unwrap();
                        if let Some(offer) = state.offer.as_ref() {
                            let bob_e_public = P384PublicKey::from_bytes(&kex_packet[(HEADER_SIZE + 1)..plaintext_end])
                                .ok_or(Error::FailedAuthentication)?;
                            let noise_ee = offer.alice_e_keypair.agree(&bob_e_public).ok_or(Error::FailedAuthentication)?;
                            let noise_se = app.get_local_s_keypair().agree(&bob_e_public).ok_or(Error::FailedAuthentication)?;

                            let noise_ik_complete = Secret(hmac_sha512(
                                session.psk.as_bytes(),
                                &hmac_sha512(
                                    &hmac_sha512(&hmac_sha512(offer.ss_key.as_bytes(), bob_e_public.as_bytes()), noise_ee.as_bytes()),
                                    noise_se.as_bytes(),
                                ),
                            ));
                            drop(noise_ee);
                            drop(noise_se);

                            let mut c = AesGcm::new(
                                kbkdf512(noise_ik_complete.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_BOB_TO_ALICE)
                                    .first_n::<AES_KEY_SIZE>(),
                                false,
                            );
                            c.reset_init_gcm(&message_nonce);
                            c.crypt_in_place(&mut kex_packet[plaintext_end..payload_end]);
                            let gcm_tag = &kex_packet[payload_end..aes_gcm_tag_end];
                            if !c.finish_decrypt(gcm_tag) {
                                return Err(Error::FailedAuthentication);
                            }

                            // Alice has now completed Noise_IK with NIST P-384 and verified with GCM auth, but now for hybrid...

                            let (offer_id, bob_session_id, _, _, bob_hk_public_raw, bob_ratchet_key_id) =
                                parse_dec_key_offer_after_header(&kex_packet[plaintext_end..kex_packet_len], packet_type)?;

                            // Check that this is a counter offer to the original offer we sent.
                            if !offer.id.eq(offer_id) {
                                return Ok(ReceiveResult::Ignored);
                            }

                            // Kyber1024 key agreement if enabled.
                            let hybrid_kk = if JEDI && bob_hk_public_raw.len() > 0 && offer.alice_hk_keypair.is_some() {
                                if let Ok(hybrid_kk) =
                                    pqc_kyber::decapsulate(bob_hk_public_raw, &offer.alice_hk_keypair.as_ref().unwrap().secret)
                                {
                                    Some(Secret(hybrid_kk))
                                } else {
                                    return Err(Error::FailedAuthentication);
                                }
                            } else {
                                None
                            };

                            // The session key starts with the final noise_ik key and may have other things mixed into it below.
                            let mut session_key = noise_ik_complete;

                            // Mix ratchet key from previous session key (if any) and Kyber1024 hybrid shared key (if any).
                            let last_ratchet_count = if bob_ratchet_key_id.is_some() && offer.ratchet_key.is_some() {
                                session_key = Secret(hmac_sha512(offer.ratchet_key.as_ref().unwrap().as_bytes(), session_key.as_bytes()));
                                offer.ratchet_count
                            } else {
                                0
                            };
                            if let Some(hybrid_kk) = hybrid_kk.as_ref() {
                                session_key = Secret(hmac_sha512(hybrid_kk.as_bytes(), session_key.as_bytes()));
                            }

                            // Check main packet HMAC for full validation of session key.
                            if !secure_eq(
                                &hmac_sha384_2(
                                    kbkdf512(session_key.as_bytes(), KBKDF_KEY_USAGE_LABEL_HMAC).first_n::<48>(),
                                    &message_nonce,
                                    &kex_packet_saved_ciphertext[HEADER_SIZE..aes_gcm_tag_end],
                                ),
                                &kex_packet[aes_gcm_tag_end..kex_packet_len],
                            ) {
                                return Err(Error::FailedAuthentication);
                            }

                            // Alice has now completed and validated the full hybrid exchange.

                            let reply_counter = session.send_counter.fetch_add(1, Ordering::SeqCst);
                            let next_ratchet_count = last_ratchet_count + 1;

                            let session_key = SessionKey::new(
                                session_key,
                                Role::Alice,
                                current_time,
                                reply_counter,
                                next_ratchet_count,
                                true, // Alice knows Bob got the offer
                                hybrid_kk.is_some(),
                            );

                            drop(state);
                            let mut state = session.state.write().unwrap();

                            let _ = state.remote_session_id.replace(bob_session_id);
                            let next_key_index = (next_ratchet_count as usize) & 1;
                            let _ = state.session_keys[next_key_index].replace(session_key);
                            state.cur_session_key_idx = next_key_index;
                            let _ = state.offer.take();

                            return Ok(ReceiveResult::Ok);
                        }
                    }

                    // Just ignore counter-offers that are out of place. They probably indicate that this side
                    // restarted and needs to establish a new session.
                    return Ok(ReceiveResult::Ignored);
                }

                _ => return Err(Error::InvalidPacket),
            }
        }
    }
}

/// Create an send an ephemeral offer, populating ret_ephemeral_offer on success.
fn send_ephemeral_offer<SendFunction: FnMut(&mut [u8])>(
    send: &mut SendFunction,
    counter: u64,
    alice_session_id: SessionId,
    bob_session_id: Option<SessionId>,
    alice_s_public_blob: &[u8],
    alice_metadata: &[u8],
    bob_s_public: &P384PublicKey,
    bob_s_public_blob_hash: &[u8],
    noise_ss: &Secret<48>,
    current_key: Option<&SessionKey>,
    header_check_cipher: Option<&Aes>, // None to use one based on the recipient's public key for initial contact
    mtu: usize,
    current_time: i64,
    ret_ephemeral_offer: &mut Option<EphemeralOffer>, // We want to prevent copying the EphemeralOffer up the stack because it's very big. ret_ephemeral_offer will be overwritten with the returned EphemeralOffer when the call completes.
) -> Result<(), Error> {
    // Generate a NIST P-384 pair.
    let alice_e_keypair = P384KeyPair::generate();

    // Perform key agreement with the other side's static P-384 public key.
    let noise_es = alice_e_keypair.agree(bob_s_public).ok_or(Error::InvalidPacket)?;

    // Generate a Kyber1024 (hybrid PQ crypto) pair if enabled.
    let alice_hk_keypair = if JEDI {
        Some(pqc_kyber::keypair(&mut random::SecureRandom::get()))
    } else {
        None
    };

    // Get ratchet key for current key if one exists.
    let (ratchet_key, ratchet_count) = if let Some(current_key) = current_key {
        (Some(current_key.ratchet_key.clone()), current_key.ratchet_count)
    } else {
        (None, 0)
    };

    // Random ephemeral offer ID
    let id: [u8; 16] = random::get_bytes_secure();

    ////////////////////////////////////////////////////////////////
    // packet encoding for noise initial key offer and for noise rekeying
    // -> e, es, s, ss
    ////////////////////////////////////////////////////////////////

    // Create ephemeral offer packet (not fragmented yet).
    let mut packet_buf = [0_u8; 4096];
    let mut idx = HEADER_SIZE;

    idx = safe_write_all(&mut packet_buf, idx, &[SESSION_PROTOCOL_VERSION])?;
    //TODO: check this, the below line is supposed to be the blob, not just the key, right?
    idx = safe_write_all(&mut packet_buf, idx, alice_e_keypair.public_key_bytes())?;
    let plaintext_end = idx;

    idx = safe_write_all(&mut packet_buf, idx, &id)?;
    idx = safe_write_all(&mut packet_buf, idx, alice_session_id.as_bytes())?;
    idx = varint_safe_write(&mut packet_buf, idx, alice_s_public_blob.len() as u64)?;
    idx = safe_write_all(&mut packet_buf, idx, alice_s_public_blob)?;
    idx = varint_safe_write(&mut packet_buf, idx, alice_metadata.len() as u64)?;
    idx = safe_write_all(&mut packet_buf, idx, alice_metadata)?;
    if let Some(hkp) = alice_hk_keypair {
        idx = safe_write_all(&mut packet_buf, idx, &[HYBRID_KEY_TYPE_KYBER1024])?;
        idx = safe_write_all(&mut packet_buf, idx, &hkp.public)?;
    } else {
        idx = safe_write_all(&mut packet_buf, idx, &[HYBRID_KEY_TYPE_NONE])?;
    }
    if let Some(ratchet_key) = ratchet_key.as_ref() {
        idx = safe_write_all(&mut packet_buf, idx, &[0x01])?;
        idx = safe_write_all(&mut packet_buf, idx, &public_fingerprint_of_secret(ratchet_key.as_bytes())[..16])?;
    } else {
        idx = safe_write_all(&mut packet_buf, idx, &[0x00])?;
    }
    let payload_end = idx;

    // Create ephemeral agreement secret.
    let es_key = Secret(hmac_sha512(
        &hmac_sha512(&INITIAL_KEY, alice_e_keypair.public_key_bytes()),
        noise_es.as_bytes(),
    ));

    let bob_session_id = bob_session_id.map_or(0u64, |i| u64::from(i));

    let message_nonce = create_message_nonce(PACKET_TYPE_INITIAL_KEY_OFFER, counter);

    // Encrypt packet and attach AES-GCM tag.
    let gcm_tag = {
        let mut c = AesGcm::new(
            kbkdf512(es_key.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_ALICE_TO_BOB).first_n::<AES_KEY_SIZE>(),
            true,
        );
        c.reset_init_gcm(&message_nonce);
        c.crypt_in_place(&mut packet_buf[plaintext_end..payload_end]);
        c.finish_encrypt()
    };

    idx = safe_write_all(&mut packet_buf, idx, &gcm_tag)?;
    let aes_gcm_tag_end = idx;

    // Mix in static secret.
    let ss_key = Secret(hmac_sha512(es_key.as_bytes(), noise_ss.as_bytes()));
    drop(es_key);

    // HMAC packet using static + ephemeral key.
    let hmac1 = hmac_sha384_2(
        kbkdf512(ss_key.as_bytes(), KBKDF_KEY_USAGE_LABEL_HMAC).first_n::<48>(),
        &message_nonce,
        &packet_buf[HEADER_SIZE..aes_gcm_tag_end],
    );
    idx = safe_write_all(&mut packet_buf, idx, &hmac1)?;
    let hmac1_end = idx;

    // Add secondary HMAC to verify that the caller knows the recipient's full static public identity.
    let hmac2 = hmac_sha384_2(bob_s_public_blob_hash, &message_nonce, &packet_buf[HEADER_SIZE..hmac1_end]);
    idx = safe_write_all(&mut packet_buf, idx, &hmac2)?;
    let packet_end = idx;

    let mut init_header_check_cipher_tmp = None;
    send_with_fragmentation(
        send,
        &mut packet_buf[..packet_end],
        mtu,
        PACKET_TYPE_INITIAL_KEY_OFFER,
        bob_session_id,
        ratchet_count,
        counter,
        header_check_cipher.unwrap_or_else(|| {
            init_header_check_cipher_tmp = Some(Aes::new(
                kbkdf512(&bob_s_public_blob_hash, KBKDF_KEY_USAGE_LABEL_HEADER_CHECK).first_n::<HEADER_CHECK_AES_KEY_SIZE>(),
            ));
            init_header_check_cipher_tmp.as_ref().unwrap()
        }),
    )?;

    *ret_ephemeral_offer = Some(EphemeralOffer {
        id,
        creation_time: current_time,
        ratchet_count,
        ratchet_key,
        ss_key,
        alice_e_keypair,
        alice_hk_keypair,
    });

    Ok(())
}

fn set_packet_header(
    packet: &mut [u8],
    fragment_count: usize,
    fragment_no: usize,
    packet_type: u8,
    recipient_session_id: u64,
    ratchet_count: u64,
    counter: u64,
) -> Result<(), Error> {
    debug_assert!(packet.len() >= MIN_PACKET_SIZE);
    debug_assert!(fragment_count > 0);
    debug_assert!(fragment_no < MAX_FRAGMENTS);
    debug_assert!(packet_type <= 0x0f); // packet type is 4 bits
    if fragment_count <= MAX_FRAGMENTS {
        // [0-46]            recipient session ID
        // [47-47]           ratchet count least significant bit (key index)
        // -- start of header check cipher single block encrypt --
        // [48-51]           packet type (0-15)
        // [52-57]           fragment count (1..64 - 1, so 0 means 1 fragment)
        // [58-63]           fragment number (0..63)
        // [64-127]          64-bit counter
        memory::store_raw(
            (u64::from(recipient_session_id)
                | (ratchet_count & 1).wrapping_shl(47)
                | (packet_type as u64).wrapping_shl(48)
                | ((fragment_count - 1) as u64).wrapping_shl(52)
                | (fragment_no as u64).wrapping_shl(58))
            .to_le(),
            packet,
        );
        memory::store_raw(counter.to_le(), &mut packet[8..]);
        Ok(())
    } else {
        unlikely_branch();
        Err(Error::DataTooLarge)
    }
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct MessageNonce(u64, u32);

/// Create a 12-bit AES-GCM nonce.
///
/// The primary information that we want to be contained here is the counter and the
/// packet type. The former makes this unique and the latter's inclusion authenticates
/// it as effectively AAD. Other elements of the header are either not authenticated,
/// like fragmentation info, or their authentication is implied via key exchange like
/// the session ID.
///
/// This is also used as part of HMAC authentication for key exchange packets.
#[inline(always)]
fn create_message_nonce(packet_type: u8, counter: u64) -> [u8; 12] {
    memory::to_byte_array(MessageNonce(counter.to_le(), (packet_type as u32).to_le()))
}

/// Break a packet into fragments and send them all.
/// The contents of packet[] are mangled during this operation, so it should be discarded after.
fn send_with_fragmentation<SendFunction: FnMut(&mut [u8])>(
    send: &mut SendFunction,
    packet: &mut [u8],
    mtu: usize,
    packet_type: u8,
    recipient_session_id: u64,
    ratchet_count: u64,
    counter: u64,
    header_check_cipher: &Aes,
) -> Result<(), Error> {
    let packet_len = packet.len();
    let fragment_count = ((packet_len as f32) / (mtu as f32)).ceil() as usize;
    let mut fragment_start = 0;
    let mut fragment_end = packet_len.min(mtu);
    for fragment_no in 0..fragment_count {
        let fragment = &mut packet[fragment_start..fragment_end];
        set_packet_header(
            fragment,
            fragment_count,
            fragment_no,
            packet_type,
            recipient_session_id,
            ratchet_count,
            counter,
        )?;
        header_check_cipher.encrypt_block_in_place(&mut fragment[6..22]);
        send(fragment);
        fragment_start = fragment_end - HEADER_SIZE;
        fragment_end = (fragment_start + mtu).min(packet_len);
    }
    Ok(())
}

/// Parse KEY_OFFER and KEY_COUNTER_OFFER starting after the unencrypted public key part.
fn parse_dec_key_offer_after_header(
    incoming_packet: &[u8],
    packet_type: u8,
) -> Result<(&[u8], SessionId, &[u8], &[u8], &[u8], Option<&[u8]>), Error> {
    let mut p = &incoming_packet[..];
    let offer_id = safe_read_exact(&mut p, 16)?;

    let mut session_id_buf = 0_u64.to_ne_bytes();
    session_id_buf[..SESSION_ID_SIZE].copy_from_slice(safe_read_exact(&mut p, SESSION_ID_SIZE)?);
    let alice_session_id = SessionId::new_from_u64_le(u64::from_ne_bytes(session_id_buf)).ok_or(Error::InvalidPacket)?;

    let alice_s_public_blob_len = varint_safe_read(&mut p)?;
    let alice_s_public_blob = safe_read_exact(&mut p, alice_s_public_blob_len as usize)?;

    let alice_metadata_len = varint_safe_read(&mut p)?;
    let alice_metadata = safe_read_exact(&mut p, alice_metadata_len as usize)?;

    let alice_hk_public_raw = match safe_read_exact(&mut p, 1)?[0] {
        HYBRID_KEY_TYPE_KYBER1024 => {
            if packet_type == PACKET_TYPE_INITIAL_KEY_OFFER {
                safe_read_exact(&mut p, pqc_kyber::KYBER_PUBLICKEYBYTES)?
            } else {
                safe_read_exact(&mut p, pqc_kyber::KYBER_CIPHERTEXTBYTES)?
            }
        }
        _ => &[],
    };

    if p.is_empty() {
        return Err(Error::InvalidPacket);
    }
    let alice_ratchet_key_fingerprint = if safe_read_exact(&mut p, 1)?[0] == 0x01 {
        Some(safe_read_exact(&mut p, 16)?)
    } else {
        None
    };

    Ok((
        offer_id, //always 16 bytes
        alice_session_id,
        alice_s_public_blob,
        alice_metadata,
        alice_hk_public_raw,
        alice_ratchet_key_fingerprint, //always 16 bytes
    ))
}

impl SessionKey {
    /// Create a new symmetric shared session key and set its key expiration times, etc.
    fn new(key: Secret<64>, role: Role, current_time: i64, current_counter: u64, ratchet_count: u64, confirmed: bool, jedi: bool) -> Self {
        let a2b: Secret<AES_KEY_SIZE> = kbkdf512(key.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_ALICE_TO_BOB).first_n_clone();
        let b2a: Secret<AES_KEY_SIZE> = kbkdf512(key.as_bytes(), KBKDF_KEY_USAGE_LABEL_AES_GCM_BOB_TO_ALICE).first_n_clone();
        let (receive_key, send_key) = match role {
            Role::Alice => (b2a, a2b),
            Role::Bob => (a2b, b2a),
        };
        Self {
            ratchet_count,
            rekey_at_time: current_time
                .checked_add(REKEY_AFTER_TIME_MS + ((random::xorshift64_random() as u32) % REKEY_AFTER_TIME_MS_MAX_JITTER) as i64)
                .unwrap(),
            rekey_at_counter: current_counter.checked_add(REKEY_AFTER_USES).unwrap(),
            expire_at_counter: current_counter.checked_add(EXPIRE_AFTER_USES).unwrap(),
            secret_fingerprint: public_fingerprint_of_secret(key.as_bytes())[..16].try_into().unwrap(),
            ratchet_key: kbkdf512(key.as_bytes(), KBKDF_KEY_USAGE_LABEL_RATCHETING),
            receive_key,
            send_key,
            receive_cipher_pool: Mutex::new(Vec::with_capacity(2)),
            send_cipher_pool: Mutex::new(Vec::with_capacity(2)),
            role,
            confirmed,
            jedi,
        }
    }

    fn get_send_cipher(&self, counter: u64) -> Result<Box<AesGcm>, Error> {
        if counter < self.expire_at_counter {
            Ok(self
                .send_cipher_pool
                .lock()
                .unwrap()
                .pop()
                .unwrap_or_else(|| Box::new(AesGcm::new(self.send_key.as_bytes(), true))))
        } else {
            unlikely_branch();

            // Not only do we return an error, but we also destroy the key.
            let mut scp = self.send_cipher_pool.lock().unwrap();
            scp.clear();
            self.send_key.nuke();

            Err(Error::MaxKeyLifetimeExceeded)
        }
    }

    fn return_send_cipher(&self, c: Box<AesGcm>) {
        self.send_cipher_pool.lock().unwrap().push(c);
    }

    fn get_receive_cipher(&self) -> Box<AesGcm> {
        self.receive_cipher_pool
            .lock()
            .unwrap()
            .pop()
            .unwrap_or_else(|| Box::new(AesGcm::new(self.receive_key.as_bytes(), false)))
    }

    fn return_receive_cipher(&self, c: Box<AesGcm>) {
        self.receive_cipher_pool.lock().unwrap().push(c);
    }
}

/// Write src into buffer starting at the index idx. If buffer cannot fit src at that location, nothing at all is written and Error::UnexpectedBufferOverrun is returned. No other errors can be returned by this function. An idx incremented by the amount written is returned.
fn safe_write_all(buffer: &mut [u8], idx: usize, src: &[u8]) -> Result<usize, Error> {
    let dest = &mut buffer[idx..];
    let amt = src.len();
    if dest.len() >= amt {
        dest[..amt].copy_from_slice(src);
        Ok(idx + amt)
    } else {
        unlikely_branch();
        Err(Error::UnexpectedBufferOverrun)
    }
}

/// Write a variable length integer, which can consume up to 10 bytes. Uses safe_write_all to do so.
fn varint_safe_write(buffer: &mut [u8], idx: usize, v: u64) -> Result<usize, Error> {
    let mut b = [0_u8; varint::VARINT_MAX_SIZE_BYTES];
    let i = varint::encode(&mut b, v);
    safe_write_all(buffer, idx, &b[0..i])
}

/// Read exactly amt bytes from src and return the slice those bytes reside in. If src is smaller than amt, Error::InvalidPacket is returned. if the read was successful src is incremented to start at the first unread byte.
fn safe_read_exact<'a>(src: &mut &'a [u8], amt: usize) -> Result<&'a [u8], Error> {
    if src.len() >= amt {
        let (a, b) = src.split_at(amt);
        *src = b;
        Ok(a)
    } else {
        unlikely_branch();
        Err(Error::InvalidPacket)
    }
}

/// Read a variable length integer, which can consume up to 10 bytes. Uses varint_safe_read to do so.
fn varint_safe_read(src: &mut &[u8]) -> Result<u64, Error> {
    let (v, amt) = varint::decode(*src).ok_or(Error::InvalidPacket)?;
    let (_, b) = src.split_at(amt);
    *src = b;
    Ok(v)
}

/// Shortcut to HMAC data split into two slices.
fn hmac_sha384_2(key: &[u8], a: &[u8], b: &[u8]) -> [u8; 48] {
    let mut hmac = HMACSHA384::new(key);
    hmac.update(a);
    hmac.update(b);
    hmac.finish()
}

/// HMAC-SHA512 key derivation based on: https://csrc.nist.gov/publications/detail/sp/800-108/final (page 12)
/// Cryptographically this isn't meaningfully different from HMAC(key, [label]) but this is how NIST rolls.
fn kbkdf512(key: &[u8], label: u8) -> Secret<64> {
    Secret(hmac_sha512(key, &[0, 0, 0, 0, b'Z', b'T', label, 0, 0, 0, 0, 0x02, 0x00]))
}

/// Get a hash of a secret that can be used as a public key fingerprint to check ratcheting during key exchange.
fn public_fingerprint_of_secret(key: &[u8]) -> [u8; 48] {
    let mut tmp = SHA384::new();
    tmp.update(&[0xf0, 0x0d]); // arbitrary salt
    tmp.update(key);
    tmp.finish()
}
